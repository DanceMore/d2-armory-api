// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package character

import (
	"context"
	"github.com/nokka/d2-armory-api/internal/domain"
	"sync"
)

// Ensure, that parserMock does implement parser.
// If this is not the case, regenerate this file with moq.
var _ parser = &parserMock{}

// parserMock is a mock implementation of parser.
//
// 	func TestSomethingThatUsesparser(t *testing.T) {
//
// 		// make and configure a mocked parser
// 		mockedparser := &parserMock{
// 			ParseFunc: func(name string) (*domain.Character, error) {
// 				panic("mock out the Parse method")
// 			},
// 		}
//
// 		// use mockedparser in code that requires parser
// 		// and then make assertions.
//
// 	}
type parserMock struct {
	// ParseFunc mocks the Parse method.
	ParseFunc func(name string) (*domain.Character, error)

	// calls tracks calls to the methods.
	calls struct {
		// Parse holds details about calls to the Parse method.
		Parse []struct {
			// Name is the name argument value.
			Name string
		}
	}
	lockParse sync.RWMutex
}

// Parse calls ParseFunc.
func (mock *parserMock) Parse(name string) (*domain.Character, error) {
	if mock.ParseFunc == nil {
		panic("parserMock.ParseFunc: method is nil but parser.Parse was just called")
	}
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockParse.Lock()
	mock.calls.Parse = append(mock.calls.Parse, callInfo)
	mock.lockParse.Unlock()
	return mock.ParseFunc(name)
}

// ParseCalls gets all the calls that were made to Parse.
// Check the length with:
//     len(mockedparser.ParseCalls())
func (mock *parserMock) ParseCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockParse.RLock()
	calls = mock.calls.Parse
	mock.lockParse.RUnlock()
	return calls
}

// Ensure, that characterRepositoryMock does implement characterRepository.
// If this is not the case, regenerate this file with moq.
var _ characterRepository = &characterRepositoryMock{}

// characterRepositoryMock is a mock implementation of characterRepository.
//
// 	func TestSomethingThatUsescharacterRepository(t *testing.T) {
//
// 		// make and configure a mocked characterRepository
// 		mockedcharacterRepository := &characterRepositoryMock{
// 			FindFunc: func(ctx context.Context, id string) (*domain.Character, error) {
// 				panic("mock out the Find method")
// 			},
// 			StoreFunc: func(ctx context.Context, character *domain.Character) error {
// 				panic("mock out the Store method")
// 			},
// 			UpdateFunc: func(ctx context.Context, character *domain.Character) error {
// 				panic("mock out the Update method")
// 			},
// 		}
//
// 		// use mockedcharacterRepository in code that requires characterRepository
// 		// and then make assertions.
//
// 	}
type characterRepositoryMock struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context, id string) (*domain.Character, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(ctx context.Context, character *domain.Character) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, character *domain.Character) error

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Character is the character argument value.
			Character *domain.Character
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Character is the character argument value.
			Character *domain.Character
		}
	}
	lockFind   sync.RWMutex
	lockStore  sync.RWMutex
	lockUpdate sync.RWMutex
}

// Find calls FindFunc.
func (mock *characterRepositoryMock) Find(ctx context.Context, id string) (*domain.Character, error) {
	if mock.FindFunc == nil {
		panic("characterRepositoryMock.FindFunc: method is nil but characterRepository.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx, id)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//     len(mockedcharacterRepository.FindCalls())
func (mock *characterRepositoryMock) FindCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *characterRepositoryMock) Store(ctx context.Context, character *domain.Character) error {
	if mock.StoreFunc == nil {
		panic("characterRepositoryMock.StoreFunc: method is nil but characterRepository.Store was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Character *domain.Character
	}{
		Ctx:       ctx,
		Character: character,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(ctx, character)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//     len(mockedcharacterRepository.StoreCalls())
func (mock *characterRepositoryMock) StoreCalls() []struct {
	Ctx       context.Context
	Character *domain.Character
} {
	var calls []struct {
		Ctx       context.Context
		Character *domain.Character
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *characterRepositoryMock) Update(ctx context.Context, character *domain.Character) error {
	if mock.UpdateFunc == nil {
		panic("characterRepositoryMock.UpdateFunc: method is nil but characterRepository.Update was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Character *domain.Character
	}{
		Ctx:       ctx,
		Character: character,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, character)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedcharacterRepository.UpdateCalls())
func (mock *characterRepositoryMock) UpdateCalls() []struct {
	Ctx       context.Context
	Character *domain.Character
} {
	var calls []struct {
		Ctx       context.Context
		Character *domain.Character
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
